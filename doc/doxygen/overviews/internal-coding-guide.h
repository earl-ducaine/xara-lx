
/////////////////////////////////////////////////////////////////////////////
// Name:        internal-coding-guide.h
// Purpose:     Guide to navigating the Camelot code base and contributing.
// Author:      Xoanon Graphics team
// Licence:     MIT
/////////////////////////////////////////////////////////////////////////////

/**

@page internal-coding-guide Rendering Overview v2

@tableofcontents



 * Some history:



 * Specialized terms:


@node Architecture of Xoamorph
@chapter Architecture of Xoamorph

There are several concepts used to organize and manage complexity in
the Xoamorph project. At the highest level the project separated into
an OS layer, a kernal layer and a tool layer.

The OS layer, can be found in the @code{wxOil}
<@b{wx}Widgets><@b{O}S><@b{i}nterface><@b{l}ayer> folder. This layer
interacts directly with wxWidgets, expressing the abstract epplication
interface components, e.g. buttons, menus, canvas, etc., in terms of
wxWidgets GUI elements and translating events generated by user
interactions into internal representations of the events that various
abstract components understand.

wxWidgets is a C++ oriented toolkit, and uses the common convention of
specialization and inheritance to dispatch events (along with event
table macros, or a dynamic binding mechanism) and express graphical
elements that the user can interact with. The following table sumeraze
the specializations of wxWidget classes.



@multitable @columnfractions 0.2 0.4 0.4
@headitem Filename@footnote{For each filename there
          are two files: one with the .h extension and one with the
          .cpp} @tab Class Name @tab wxWidget Class

@item @code{basebar}
@tab @code{BaseBar}
@tab @code{wxWindow}

@item @code{bblwnd}
@tab @code{BubbleHelpWnd}
@tab @code{wxWindow}

@item @code{camdoctp}
@tab @code{CCamDocTemplate}
@tab @code{wxDocTemplate}

@item @code{camframe}
@tab @code{CCamFrame}
@tab @code{wxDocMDIParentFrame}

@item @code{camelot}
@tab @code{CCamApp}
@tab @code{wxApp}
@item
@tab @code{wxWindowDeletionWatcher}
@tab @code{wxObject}

@item @code{camplatform}
@tab @code{CamPlatformDependent}
@tab @code{wxPlatformDependent}

@item @code{camprocess}
@tab @code{CamProcess}
@tab @code{wxProcess}
@item
@tab @code{CamLaunchProcess}
@tab @code{wxProcess}

@item @code{cartprov}
@tab @code{CamArtProvider}
@tab @code{wxEvtHandler}
@item
@tab @code{wxCamArtProviderEvent}
@tab @code{wxEvent}

@item @code{camview}
@tab @code{CCamView}
@tab @code{wxView}
@item
@tab @code{CViewFileDropTarget}
@tab @code{wxFileDropTarget}

@item @code{cartctl}
@tab @code{wxCamArtControl}
@tab @code{wxControl}
@item
@tab @code{wxCamArtControlXmlHandler}
@tab @code{wxXmlResourceHandler}

@item @code{ccolbar}
@tab @code{CColourBar}
@tab @code{wxWindow}

@item @code{dlgevt}
@tab @code{DialogEventHandler}
@tab @code{wxEvtHandler}
@item
@tab @code{wxCamDialogEvent}
@tab @code{wxEvent}

@item @code{dlgmgr}
@tab @code{CamelotTreeItemData}
@tab @code{wxTreeItemData}

@item @code{dockbar}
@tab @code{OILDockingBar}
@tab @code{wxToolBar}

@item @code{dragmgr}
@tab @code{CaptureHandler}
@tab @code{wxEvtHandler}

@item @code{drawctl}
@tab @code{wxCamDrawControlEvent}
@tab @code{wxEvent}
@item
@tab @code{wxCamDrawControl}
@tab @code{wxEvtHandler}
@item
@tab @code{wxCamDrawControlXmlHandler}
@tab @code{wxXmlResourceHandler}
@item
@tab @code{wxCamArtControlEvent}
@tab @code{wxEvent}

@item @code{dropdown}
@tab @code{wxCamVListBoxComboPopup}
@tab @code{wxVListBoxComboPopup}

@item @code{errorbox}
@tab @code{CInformErrorDialog}
@tab @code{wxDialog}

@item @code{errors}
@tab @code{StackWalker}
@tab @code{wxStackWalker}

@item @code{filedlgs}
@tab @code{BaseFileDialog}
@tab @code{wxFileDialog}

@item @code{griddropdown}
@tab @code{wxCamGridPopup}
@tab @code{wxGridComboPopup}

@item @code{ktimer}
@tab @code{CamTimer}
@tab @code{wxTimer}

@item @code{oilmenus}
@tab @code{wxCamMenuBar}
@tab @code{wxMenuBar}
@end multitable

@multitable @columnfractions 0.2 0.4 0.4
@item @code{oilprefs}
@tab @code{OILPreferences}
@tab @code{wxConfig}

@item @code{oilruler}
@tab @code{LegendLabel}
@tab @code{wxWindow}
@item
@tab @code{OILRuler}
@tab @code{wxWindow}
@item
@tab @code{OriginGadget}
@tab @code{wxWindow}

@item @code{prdlgctl}
@tab @code{CCPrintInfo}
@tab @code{wxPrintDialogData}
@item
@tab @code{CCPrintDialog}
@tab @code{wxPrintDialog}
@item
@tab @code{CCPrintToFileDialog}
@tab @code{wxFileDialog}

@item @code{rendwnd}
@tab @code{CRenderWnd}
@tab @code{wxWindow}

@item @code{scroller}
@tab @code{CScrollerCorner}
@tab @code{wxWindow}
@item
@tab @code{CWinScroller}
@tab @code{wxScrollBar}

@item @code{ralphdoc}
@tab @code{RalphDocument}
@tab @code{wxEvtHandler}

@item @code{wincoord}
@tab @code{WinCoord}
@tab @code{wxPoint}

@item @code{winrect}
@tab @code{WinRect}
@tab @code{wxRect}
@end multitable

The following table describes how each wxWidget class is used

@table @asis
@item @code{wxApp}
@code{CCamApp} inherits @code{wxApp} to represent the top level class
of the application. Functionality inherited includes managing the @emph{top window}
and support for @emph{video modes}. @code{wxApp} inherits aditional
application-wide functionality from @code{wxAppConsole}.

@item @code{wxConfig}
@code{OILPreferences} inherits from @code{wxConfig}, using the
inherited class as a framework for managing the over-all persistent
configurations of the application.

@item @code{wxControl}
An important base class, a control is generally a small window which
processes user input and/or displays one or more item of
data. @code{wxComboCtrlBase}, @code{wxCamDrawControl}, and
@code{wxCamArtControl} inheret from it.

The @code{ControlList} class organizes a collection of
@code{wxControl} derived objects and presents them to the user.

@item @code{wxDialog}
@code{wxDialog} provides the fundamental dialog functionality for the
 @code{CInformErrorDialog} and @code{wxDocTemplate} classes.

A dialog box is a window which can be moved around the screen. It's
scrollable has a title bar and maybe a system menu. It can contain
controls and other windows. It its simplest form it contains text and
buttons that query the user for some response, e.g. @emph{OK}/@emph{Cancel}

@item @code{wxDocMDIParentFrame}
@code{CCamFrame} is the top level frame of the applicaiton, inheriting
from @code{wxDocMDIParentFrame} to allow the class to coordinate with
classes derived from @code{wxView}, @code{wxDocument},
@code{wxDocManager} and @code{wxDocTemplate}.

@item @code{wxDocTemplate}
Used to implement @code{CCamDocTemplate}.

@item @code{wxEvent}
Provides a basic event structure which serves as the foundation for
the following application specific events:
@code{wxCamArtProviderEvent}, @code{wxCamDialogEvent},
@code{wxCamDrawControlEvent}, and @code{wxCamArtControlEvent}

@item @code{wxEvtHandler}
This is the wxWidgets interface for accetping events, independant of
how or even if the object created from it is displayed. Many wxWidgets
classes inherit from it, especially @code{wxWindow}. Application
classes derived directly from this (as opposed to indirectly through
other wxWidgets classes) are: @code{CamArtProvider}, @code{wxCamArtControl},
@code{DialogEventHandler}, @code{CaptureHandler}, and @code{wxCamDrawControl}.

@item @code{wxFileDialog}
Provides a nice, platform appropriate file chooser
dialog.

@code{CCPrintToFileDialog}, and @code{BaseFileDialog} inherit from it.

@item @code{wxFileDropTarget}
provides a sink for classes that accept a dragged file, used by
@code{CViewFileDropTarget}.


@item @code{wxMenuBar}
Conventional menu bar, i.e. series of menus accessible from the top of
a frame. Used for exactly this purpose by @code{wxCamMenuBar}.


@item @code{wxObject}
A root class of many wxWidgets classes. Provides basic dynamic
alocation and dealocation, including debug wrappers for @code{new} and
@code{free}. Used by both @code{wxPlatformDependent} and
@code{wxWindowDeletionWatcher}.


@item @code{wxPoint}
Inherited by @code{WinCoord}, cartesian coordinate of screen position
in units that wxWidgets understands.

@item @code{wxPrintDialogData}
Inherited by @code{CCPrintInfo}. Provides way to customize visual
characteristics of the print dialog.

@item @code{wxPrintDialog}
Inherited by @code{CCPrintDialog}. Provides a nice, platform appropriate print
dialog.

@item @code{wxProcess}
Used by both @code{CamLaunchProcess} and @code{CamProcess} to
coordinate OS process execution using @code{wxExecute} which is not
subclassed, but instead used directly.


@item @code{wxRect}
Inherited by @code{WinRect}, represents a rectangle with cartesian integer
coordinates in units that wxWidgets understands.

@item @code{wxScrollBar}
Used by @code{CWinScroller} for low level scrolling where a higher
level scrolling component is not suitable.


@item @code{wxScrolledWindow}

Is really a @code{typedef} of @code{wxScrolled<wxPanel>}. It provides
a scrolled window that needs to have child controls. The
@code{wxGridComboPopup} inherits from this class to access this
functionality.


@item @code{wxStackWalker}
@code{StackWalker} wraps this class providing debugging support for
inspecting stack frames, in C++ (and compatible) code.

@item @code{wxTimer}
Inherited by @code{CamTimer} to provide a series of timed events.


@item @code{wxToolBar}
Provides dockable toolbar through the @code{OILDockingBar} class.

@item @code{wxTreeItemData}
@code{CamelotTreeItemData} wraps this class to provide convenient
mechanism for dynamic allocation of objects. This mechanism is
distinct from @code{wxObject}, and is intended for classes which are
used to create large numbers of objects for which wxObject would be
too much overhead.

@item @code{wxVListBoxComboPopup}
wrapped by @code{wxCamVListBoxComboPopup} and used for the
application's dropdown components.

@item @code{wxView}
This class is a core API for wxWidgets' MDI. It is inherited by
@code{CCamView} which uses the API to coordinate activities with the
@code{wxDocMDIParentFrame} derived @code{CCamFrame} class.

@item @code{wxWindow}
Fundamental, low-level, unit of graphical display. Used as the base of
a number of classes that need to present visual information to the
user, especially informatin that requires interaction, including:
@code{BaseBar}, @code{BubbleHelpWnd}, @code{CColourBar},
@code{CRenderWnd}, @code{CScrollerCorner}, @code{LegendLabel},
@code{OILRuler}, @code{OriginGadget}


@item @code{wxXmlResourceHandler}
Itself a wrapper class providing access to XML manipulation
functionality. It's used to implement
@code{wxCamDrawControlXmlHandler} and @code{wxCamArtControlXmlHandler}
@end table


@multitable @columnfractions 0.15 0.35 0.50
@headitem Filename@footnote{For each filename there
          are two files: one with the .h extension and one with the
          .cpp} @tab Class Name  @tab Description


@item @code{sgliboil}
@tab @code{ClipartImportParam}
@tab Manage clipart files.


@item @code{sgliboil}
@tab @code{ClipartImportParam}
@tab Manage clipart files.
@item @code{sglinepr}
@tab @code{SGalleryLinePropertiesDlg}
@tab Manage Line/Stroke gallery.
@item @code{sglinepr}
@tab @code{SGalleryLinePropertiesDlg}
@tab Manage Line/Stroke gallery.
@item @code{sgrmfile}
@tab @code{LibSettingsListItem}
@tab Maintain application settings file.
@item
@tab @code{LibSettings}
@item
@tab
@item @code{speedtst}
@tab @code{OpTimeDraw}
@tab Misc. performance tests/benchmarks.
@item
@tab @code{OpClearCache}
@item
@tab @code{OpThrottleCache}
@item
@tab
@item @code{stemplate}
@tab @code{WebAddress}
@tab Library for handling representations of URLs.
@item @code{svnversion}
@tab @emph{N/A}
@tab Misc. configuration management functions.
@item @code{tablet}
@tab @code{WinTabPressurePen}
@tab Tablet-style pressure pens.
@item @code{textfuns}
@tab @code{CharMetrics}
@tab Grabbag of classes for handling text.
@item
@tab TextManager
@item
@tab
@item @code{ttfonts}
@tab @code{CTemplateManager}
@tab Helper class for managing template files.
@item @code{ttfonts}
@tab @code{TTFontMan}
@tab Static class and helper classes for interacting with TrueType fonts.
@item
@tab @code{TTFont}
@item
@tab
@item @code{tunemem}
@tab @code{TunedMemory}
@tab Wrapper around CCMalloc and CCFree. Class provides features to
          better understand memory usage and track down errors,
          especially leaks.
@item @code{unicdman}
@tab @code{UnicodeManager}
@tab Misc. Unicode utilities.
@item @code{varstr}
@tab @code{StringVar}
@tab Extends @code{StringBase} to become self-sizing, i.e. methods
          @code{SafeCat}, @code{SafeCopy}, @code{EnsureAlloc}
@item @code{vkextra}
@tab @emph{N/A}
@tab A viewport onto the canvas supporting such things as scrooled to
          possition and zoom level, as well as misc visual cues
          (grids) and interactions (snapping).
@item @code{vstate}
@tab @code{ViewState}
@tab A viewport onto the canvas supporting such things as scrooled to
          possition and zoom level, as well as misc visual cues
          (grids) and interactions (snapping).
@item @code{wincoord}
@tab @code{WinCoord}
@tab Cartesian coordinate of screen position in units that wxWidgets understands.
@item @code{winrect}
@tab @code{WinRect}
@tab Lowest level unit visible screen area to which we render.
@item @code{wxkeymap}
@tab @code{wxKeyMap}
@tab Provide abstraction for keyboard keys in wxWidgets.
@item @code{xmlutils}
@tab @code{CXMLUtils}
@tab Provides wrapper for the libxml library.
@item @code{xpoilflt}
@tab @code{PluginFilterProcess}
@tab Manage filter files, e.g. pathnames, binary streams, etc.
@item
@tab @code{PluginOILFilter}
@item
@tab @code{AutoCleanOILFilter}
@item
@tab @code{PathNameListItem}
@end multitable


@node Anatomy of an Interaction
@chapter Anatomy of an Interaction

This chapter puts the major architectural features into context by
presenting a user interaction, the creation of a default filled
rectangle, from beginning to end.

To initiate an operation, the user first selects the tool that they
want to use, in our case the Rectangle tool. wxWidgets detects this
click and dispatches it to the application via
@code{wxAppConsoleBase::HandleEvent()}, which knows about any windows
under the control of @code{wxApp} which is inheritted by
@code{CCamApp}.

The area of the screen in which we clicked is 'owned' by a
@code{wxCamArtControl} object, @code{TOOL_OPTOKEN_RECTANGLE} (AKA
@code{TOOL5}).

The following shows how the @code{wxCamArtControlEvent} event
controler is associated with the @code{wxCamArtControl} class through
wxWidgets event macros and event tables. And how the specific event
@code{EVT_MOUSE_EVENTS} is associated with the method of the object
clicked, @code{wxCamArtControl::OnMouseEvent} as shown in @ref{fig:ex1}

@float Figure,fig:ex1
@smallexample
DEFINE_EVENT_TYPE(wxEVT_CAMARTCONTROL_INVOKE)
IMPLEMENT_DYNAMIC_CLASS(@b{wxCamArtControlEvent}, wxEvent)

IMPLEMENT_DYNAMIC_CLASS(@b{wxCamArtControl}, wxControl)
BEGIN_EVENT_TABLE(wxCamArtControl, wxControl)
    EVT_CAMARTCONTROL_INVOKE(wxID_ANY, wxCamArtControl::OnInvoke)
    EVT_PAINT(wxCamArtControl::OnPaint)
    @b{EVT_MOUSE_EVENTS}(@b{wxCamArtControl::OnMouseEvent})
    EVT_TIMER(_R(IDC_WXCAMARTCONTROL_AUTOREPEAT), wxCamArtControl::OnTimer)
END_EVENT_TABLE();
@end smallexample
@end float

In @code{wxCamArtControl::OnMouseEvent} we change the state of the
button to @code{CAF_SELECTED} note that we have a button click,
@code{ButtonClick}, and then synchronously 'propagate' the click to the parent so
that it can do any additional handling. @emph{Note, should use
@code{wxEvent::ShouldPropagate} to accomplish this?).

@code{DialogEventHandler::MouseEvent} is invoked as though it were an
'organic' event, and calls
@code{DialogManager::Event}.
@code{DialogManager::Event} determines whether a DIM, i.e. commond, is
indicated, and if so dispatches that command asynchronicly, unless
it's generated in a modal context (which we're not). To do that we
first create a defered event.

@smallexample
wxCamDialogEvent deferredevent (wxEVT_CAMDIALOG_DEFERREDMSG,
event.GetId(), msg);
@end smallexample

We then add it as a pending event using the window's same event
handler, calling @code{AddPendingEvent}.

The view, then is put into a 'waiting for click' state. When a left
click is recieved, and the mouse moves, the application goes into a
drag stack where the mouse is 'captured'.

wxWidgets then begins to process pending events, which dispatches the
event to
@code{DialogEventHandler::CamDialogEvent}. @code{DialogManager} then
broadcasts the event: @code{MessageHandler::Broadcast}.

The command ultimately starts being processed usin the
@code{OpDescriptor::Invoke} function, which results in
@code{QuickShapeBase::SelectChange} being called.


@smallexample
p (((StrokeColourAttribute *)
CurrentAttrs[ATTR_STROKECOLOUR].pAttr)->Colour).SourceColour.RGBT
@end smallexample

@smallexample
// change to 1?
1205			if (RR_LINEWIDTH()==0 || LineQuality < Quality::FullLine)
1206				PenWidth = 0;
1207			else

@end smallexample

Stack trace setting color (reversed)
@smallexample
RenderRegion::SetLineColour
OpNewRegShape::RenderDragBlobs
OpNewRegShape::DoDrag
QuickShapeBase::OnClick
DocView::OnClick
CCamView::HandleDragEvent
CCamView::HandleDragEvent


The following seems to not cause the screen to update.

@code{DrawPathToOutputDevice}

@node Rendering Pipeline for Editing
@chapter Rendering Pipeline for Editing


@node Constraints on Rendering in X11
@section Constraints on Rendering in X11

Rendering is complicated by several constraints put on it by the X
Windows system. A major challenge is rationalizing those constraints
with other quite different constraints of other platforms.

1) The system must always be responsive, and able to provide the
graphical contents of any window that it owns, on-demand.

2) The system also need to be be able to update any windows that it
owns, programatically, i.e. on the initiative of the application,
rather than responding to a demand from the system to update it's window.

3) And area demanded for refresh by the system must be updated using a
grahpcial contex provided by the demand.

4) Any update initiated by the application must be done using a
graphic context that the the application specially creates.

5) It is forbiden to use an application created graphic context during
a demand update and vice-versa it is forbiden to use a demand context
during a system initialized update.


In addition to the above informally described constraints, there is a
precice set of terms defined by the application, wxWidgets, GTK/GDK,
and X11. Using these terms lets describe the two sorts of updates in words.



@node Programatic rendering
@section Programatic rendering

Programatic rendering is rending that takes place when the application
initiates the rendering, i.e. when servicing some non-paint event like
the user dragging an object on the canvas. Programatic rendering can
further be categorized as immediate or background.

The type of rendering that's immediate vs that that's background is
not clearcut. But in generaral rendering done in the background is
that which can be generated by the state of the objects without regard
to where the user is with respect to some interactive
operation. Immediate rendering is rendering that is done with respect
to user interaction. In particular dragging objects and manipulating
blobs.



@node On-demand rendering, i.e. the OnPaint event
@section On-demand rendering, i.e. the OnPaint event

wxWidgets may send the application an @code{EVT_PAINT()} event at any
time, the application is responsible for creating a wxPaintDC object,
even if the application doesn't update the screen.







@node The Render Region
@section The Render Region

Heart of rendering is the, RenderRegion







@node Coding Conventions and Style Guide
@chapter Coding Conventions and Style Guide


Be conscientious. In particular find a happy medium between

- Making as few changes as poossible to avoid cluttering up git
  history with purely stylistic changes.

- Eliminate the use of non-standard tabs, i.e. only use tab width 8.

- Prefer spaces to tabs in code.

- maximize the amount of code that fits within a vertical span.

- minimize the amount of code that extends beyond 80 columns.

- main code that's visually attractive and whose operation is visually
  reinforced by its layout.


@node Glossary
@appendix Glossary

@table @asis


@item Blob, Selection
A special purpose blob used to anotate objects, providing a visual cue
for how an object can be manipulated or otherwise editted. The
@code{BlobManager} class (@code{blobs.h and blobs.cpp}) is a single
instance class (accessed by @code{GetApplication()->GetBlobManager}
for managing selection blobs.

@item Blob
Any application object that can be rendered.

@item Camelot
Camelot was the original name of the application and still lives on in
the names of various symbols.

@item DIM
Dialog Message. A platform neutral way to propogate asynchronous
messages. Many events become DIMs, but DIMs are generally higher level
than just a single gesture event.


@end table



@node Function Index, Type Index, Glossary, Top
@appendix Function Index

@printindex fn

@node Type Index,  , Function Index, Top
@appendix Type Index

@printindex tp







**/
